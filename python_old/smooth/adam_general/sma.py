import numpy as np

from smooth.adam_general._adam_general import adam_fitter, adam_forecaster
from smooth.adam_general.adam_profile import adam_profile_creator


def sma(y, order=1, h=10, holdout=False):
    """SMA"""
    y = y.astype(np.float64)

    # ic = lambda e: np.sum(e**2)
    obs_all = len(y) + h * (1 - holdout)
    obs_in_sample = len(y) - h * holdout
    y_in_sample = y

    E_type = "A"
    T_type = "N"
    S_type = "N"

    components_num_ETS = 0
    components_num_ETS_seasonal = 0
    xreg_number = 0
    constant_required = False
    ot = np.ones_like(y_in_sample)

    def creator_sma(order):
        # lags_model_all = np.ones(shape=(order, 1))
        # This needs to be a vector of values
        lags_model_all = np.arange(1, order + 1, dtype="int32").reshape(order, 1)
        lags_model_max = int(max(lags_model_all))
        obs_states = obs_in_sample + lags_model_max

        profiles_recent_table, index_lookup_table = adam_profile_creator(
            lags_model_all=lags_model_all,
            lags_model_max=lags_model_max,
            obs_all=obs_all,
        ).values()

        # # This needs to be generated by a profileCreator() function
        # profiles_recent_table = np.mean(y_in_sample[0 : (order - 1)]) * np.ones(
        #     shape=(order, lags_model_max), dtype=np.float64
        # )

        # # This as well...
        # index_lookup_table = np.tile(
        #     np.arange(order), (obs_all + lags_model_max, 1)
        # ).T

        mat_F = np.ones((order, order)) / order
        mat_Wt = np.ones((obs_in_sample, order))

        vec_G = np.ones(order) / order
        # matVt = np.zeros((order, obs_states))
        mat_Vt = np.empty((order, obs_states))
        # matVt.fill(np.nan)

        adam_fitted = adam_fitter(
            matrixVt=mat_Vt,
            matrixWt=mat_Wt,
            matrixF=mat_F,
            vectorG=vec_G,
            lags=lags_model_all,
            indexLookupTable=index_lookup_table,
            profilesRecent=profiles_recent_table,
            E=E_type,
            T=T_type,
            S=S_type,
            nNonSeasonal=components_num_ETS,
            nSeasonal=components_num_ETS_seasonal,
            nArima=order,
            nXreg=xreg_number,
            constant=constant_required,
            vectorYt=y_in_sample,
            vectorOt=ot,
            backcast=True,
        )

        fitted_args = dict(
            matrixVt=mat_Vt,
            matrixWt=mat_Wt,
            matrixF=mat_F,
            vectorG=vec_G,
            lags=lags_model_all,
            indexLookupTable=index_lookup_table,
            profilesRecent=profiles_recent_table,
            E=E_type,
            T=T_type,
            S=S_type,
            nNonSeasonal=components_num_ETS,
            nSeasonal=components_num_ETS_seasonal,
            nArima=order,
            nXreg=xreg_number,
            constant=constant_required,
            vectorYt=y_in_sample,
            vectorOt=ot,
            backcast=True,
        )

        return adam_fitted, fitted_args

    sma_fitted, fitted_args = creator_sma(order=order)

    # need to convert some inputs to the expected dtypes. This is a temporary fix.
    fitted_args["lags"] = np.array(fitted_args["lags"], dtype="uint64")
    fitted_args["indexLookupTable"] = np.array(
        fitted_args["indexLookupTable"], dtype="uint64"
    )

    sma_forecast = adam_forecaster(
        matrixWt=fitted_args["matrixWt"],
        matrixF=fitted_args["matrixF"],
        lags=fitted_args["lags"],
        indexLookupTable=fitted_args["indexLookupTable"],
        profilesRecent=sma_fitted["profile"],
        E=fitted_args["E"],
        T=fitted_args["T"],
        S=fitted_args["S"],
        nNonSeasonal=fitted_args["nNonSeasonal"],
        nSeasonal=fitted_args["nSeasonal"],
        nArima=fitted_args["nArima"],
        nXreg=fitted_args["nXreg"],
        constant=fitted_args["constant"],
        horizon=h,
    )

    return sma_forecast
